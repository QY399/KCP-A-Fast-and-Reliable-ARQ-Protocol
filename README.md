# KCP快速可靠协议  
  
## 简介：
KCP是一种网络传输协议(ARQ，自动重传请求)，可以视它为TCP的代替品，但是它运行于用户空间，它不管底层的发送与接收，只是个纯算法实现可靠传输，它的特点是牺牲带宽来降低延迟。因为TCP协议的大公无私，经常牺牲自己速度来减少网络拥塞，它是从大局上考虑的。而KCP是自私的，它只顾自己的传输效率，从不管整个网络的拥塞情况。举个例子，TCP检测到丢包的时候，首先想到的是网络拥塞了，要放慢自己的速度别让网络更糟，而KCP想到的赶紧重传别耽误事。

## 特性：
TCP是为流量设计的（每秒内可以传输多少KB的数据），讲究的是充分利用带宽。而 KCP是为流速设计的（单个数据包从一端发送到一端需要多少时间），以10%-20%带宽浪费的代价换取了比 TCP快30%-40%的传输速度。TCP信道是一条流速很慢，但每秒流量很大的大运河，而KCP是水流湍急的小激流。KCP有正常模式和快速模式两种，通过以下策略达到提高流速的结果：

#### RTO翻倍vs不翻倍：
TCP超时计算是RTOx2，这样连续丢三次包就变成RTOx8了，十分恐怖，而KCP启动快速模式后不x2，只是x1.5（实验证明1.5这个值相对比较好），提高了传输速度。

#### 选择性重传 vs 全部重传：
TCP丢包时会全部重传从丢的那个包开始以后的数据，KCP是选择性重传，只重传真正丢失的数据包。

#### 快速重传：
发送端发送了1,2,3,4,5几个包，然后收到远端的ACK: 1, 3, 4, 5，当收到ACK3时，KCP知道2被跳过1次，收到ACK4时，知道2被跳过了2次，此时可以认为2号丢失，不用等超时，直接重传2号包，大大改善了丢包时的传输速度。

#### 延迟ACK vs 非延迟ACK：
TCP为了充分利用带宽，延迟发送ACK（NODELAY都没用），这样超时计算会算出较大 RTT时间，延长了丢包时的判断过程。KCP的ACK是否延迟发送可以调节。

#### UNA vs ACK+UNA：
ARQ模型响应有两种，UNA（此编号前所有包已收到，如TCP）和ACK（该编号包已收到），光用UNA将导致全部重传，光用ACK则丢失成本太高，以往协议都是二选其一，而 KCP协议中，除去单独的 ACK包外，所有包都有UNA信息。

#### 非退让流控：
KCP正常模式同TCP一样使用公平退让法则，即发送窗口大小由：发送缓存大小、接收端剩余接收缓存大小、丢包退让及慢启动这四要素决定。但传送及时性要求很高的小数据时，可选择通过配置跳过后两步，仅用前两项来控制发送频率。以牺牲部分公平性及带宽利用率之代价，换取了开着BT都能流畅传输的效果。

## 实现：
   底层传输协议使用 UDP。  
   采取选择性重传和快速重传，只重传真正丢失的数据包，例如连续检测某数据包被跳过，立即重传而不是等待延时，改善丢包时的传输速度。    
   KCP启动快速模式后超时计算 RTOx1.5，相较于 TCP×2 提高了传输速度。  
   实现了 ACK 发送延时可调节功能，防止超时计算时间过长。  
   除 ACK 包外，所有包加入 UNA 信息，降低丢失成本，实现快速重传。  
   正常模式下，使用 TCP 同等公平退让法则：即发送窗口大小由：发送缓存大小、接收端剩余接收缓存大小、丢包退让及慢启动这四要素决定。  
   快速模式下，启用非退让流控：传送及时性要求很高的短数据时，跳过丢包退让和慢启动，实现高效率流畅传输。   

## 怎么使用：
KCP只有两个文件，分别是MyKCP.c和MyKCP.h，代码行数1300左右。使用KCP和使用TCP有些不同，所以上手之前需要先了解下KCP如何使用，需要时间成本。

第一步，就是创建一个kcp实例，相当于一个句柄。

ikcpcb* ikcp_create(IUINT32 conv, void *user)
第二步，设置发送数据的接口，底层用哪种socket都没问题，只要能把数据发送出去，建议使用UDP，比较简单。

int output(const char *buf, int len, ikcpcb *kcp, void *user)
第三步，更新KCP状态。KCP运行于用户空间，所以需要手动去更新每个实例的状态，其实主要就是检测哪些数据包该重传了。

void ikcp_update(ikcpcb *kcp, IUINT32 current)
第四步，发送数据。调用ikcp_send之后，KCP最后会使用上面设置的output函数来将发送数据(KCP自己并不关心如何发送数据)。

int ikcp_send(ikcpcb *kcp, const char *buffer, int len)
第五步，预接收数据。先手动预接收数据，然后再调用ikcp_input将裸数据交给KCP，这些数据有可能是KCP控制报文，并不是我们要的数据。

int ikcp_input(ikcpcb *kcp, const char *data, long size)
第六步，接收数据。此时收到的数据才是真正的数据，重组操作在调用ikcp_recv之前就完成了。

int ikcp_recv(ikcpcb *kcp, char *buffer, int len)
总体上还是容易理解的，以前我们是直接使用各种socket和对端通信，各种功能由自己控制。现在是在socket之上使用了一个中间件KCP，帮忙实现快速可靠传输功能。注意一下KCP有模式的区分，不同模式下的速度表现不一样，建议把参数配好之后再使用，否则使用的都是默认的参数。

## 参数设置

#### 1.工作模式：  

int ikcp_nodelay(ikcpcb *kcp, int nodelay, int interval, int resend, int nc)  
nodelay ：是否启用 nodelay模式，0不启用；1启用。  
interval ：协议内部工作的 interval，单位毫秒，比如 10ms或者  20ms  
resend ：快速重传模式，默认0关闭，可以设置2（2次ACK跨越将会直接重传）  
nc ：是否关闭流控，默认是0代表不关闭，1代表关闭。  
普通模式： ikcp_nodelay(kcp, 0, 40, 0, 0);  
极速模式： ikcp_nodelay(kcp, 1, 10, 2, 1);  

#### 2.最大窗口：  

int ikcp_wndsize(ikcpcb *kcp, int sndwnd, int rcvwnd);  
该调用将会设置协议的最大发送窗口和最大接收窗口大小，默认为32. 这个可以理解为 TCP的 SND_BUF 和 RCV_BUF，只不过单位不一样 SND/RCV_BUF 单位是字节，这个单位是包。  

#### 3.最大传输单元：  

纯算法协议并不负责探测 MTU，默认 mtu是1400字节，可以使用ikcp_setmtu来设置该值。该值将会影响数据包归并及分片时候的最大传输单元。  

#### 4.最小RTO：  

不管是 TCP还是 KCP计算 RTO时都有最小 RTO的限制，即便计算出来RTO为40ms，由于默认的 RTO是100ms，协议只有在100ms后才能检测到丢包，快速模式下为30ms，可以手动更改该值：  

kcp->rx_minrto = 10;  

## 快在哪里

没用使用任何系统调用接口  
无需建立/关闭连接(就KCP本身来说)  
很多影响速度的参数都可配  

## 使用场景

丢包率高的网络环境下KCP的优点才会显示出来。如果不丢包，那么TCP和KCP的效率不会差别很大，可能就是少了连接建立/关闭而已。一般来讲，在公网上传输的都可以使用，特别是对实时性要求较高的程序，如LOL。